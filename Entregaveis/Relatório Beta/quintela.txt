QUESTIONNAIRES

The scope of the Questionnaires submodule includes the domains of Questionnaire, Questionnaire Instance, Questionnaire Answers and Questionnaire-Challenge.
Implementation wise each of these domains exposes a different Spring RestController and has a different service to handle the business logic. The possible operations exposed by these controllers can be found in the Swagger documentations (ref - 22).
The Questionnaire domain entity represents the wrapper of all questionnaire components. It contains the information about the questionnaire domain but also references all the challenges in the questionnaire. The questionnaire itself can not be solve, but it serves as a template in which instances of it can be created and send to multiple users to be solved.
The Questionnaire Instance, extends its parent Questionnaire, and it is this resource that is going to be sent to a user for further operations. Multiple Questionnaires Instance can derive from a single parent Questionnaire.
The Questionnaire-Challenge  domain entity is represented by a combination of the data model entity Questionnaire and a record from the many to many entity QC, which represents the associations between a questionnaire and a challenge data model entities, and the answer to the challenge present in the questionnaire.
The Questionnaire Answers domain entity is represented by a combination of the data model entities Questionnaire Answer and Answer. The questionnaires answer in data are equal to the challenges answer ones, since they both aim to resolve a challenge problem. They also respect the same mandatory mutually exclusive relationship with different types of answers, with the difference that they are bound to a different resource.


IMPLEMENTATIONS DETAILS

Server
This layer is the entry point ot the application and is responsible for its configuration. Because this is a Spring application, the entry point class "Application" is annotated with `@SpringBootApplication`. This annotation aglomerates the annotations `@Configuration`, `@EnableAutoConfiguration` and `@ComponentScan`. The `@Configuration` annotation indicates a class which declares one or more beans. The `@EnableAutoConfiguration` attempts to automatically configure your Spring application based on the jar dependencies that you have added to the classpath. The `@ComponentScan` annotation is used with the `@Configuration` annotation to tell Spring the packages to scan for annotated components.

Server configuration
The server configurations was defined on property files and were loaded during runtime taking advantage of spring mechanisms. An example of the configuration can be found on the WIKI of the GIT respository <LINL>. 

## Services
The service module can be divided into two sub layers. The Controller sublayer which handles the request routing, calls the service layer and returns the appropriate responses built. And the representation sub layer which is responsible for building the response to be returned by the controller.

#Controller
On the controller classes several annotations were used, two of the most important were: `@RestController`; specializations of `@RequestMapping`.
The `@RestController` annotation includes two other annotations `@Controller` and `@ResponseBody`. The `@Controller` is a specialization of the `@Component` annotation, allowing implementation classes to be autodetected through the classpath scanning. The `@ResponseBody` annotation binds the return value to outgoing HTTP response body. Adding to this it also uses HTTP Message converters to convert the return value to HTTP response body, serializing the response based on Content-Type present in request HTTP header.
The `@RequestMapping` annotation maps the requests's uri and HTTP method to controller's handler methods. Specializations like `@GetMapping` or `@PostMapping` are specializations which by default specify the HTTP methods, in this case the GET and POST HTTP methods respectively.

#Services
Services implement the business logic, validate input parameters and interact with the data access layer. There are 6 types of services: user, project, label, issue, comment and state.
Every service class was annotated with the `@Service` annotation, which is a specialization of the `@Component` annotation, allowing implementation classes to be autodetected through the classpath scanning.

### Validations
The parameter validation is done on the service layer using the Javax validators.
For these validators to work the service classes and methods need to be annotated with `@Validated` annotation.
The validations were done on the service classes's methods, for ache input parameter. This was done with annotations.

## Error Handling
Error handling responsibility in this solution is divided in several classes.
The class ApiExceptionHandler was marked with `@ControllerAdvice` annotation to enable application wide exception handling in a single class. This class has method to capture two application specific Exceptions (ServerException and ConstraintViolationException) and the most generic "Exception". 
The basic flow in this class is as follows: an exception will be caught and then will be mapped to ApiError's instance that maps to the json+problem standard (which can be consulted in the SWAGGER documentation). 
The class ServerExcepton extends Exception type, and its instantiated when an error occurs. This object is constructed with a message for the client, a message for the developer and an error code, which is mapped to an http error code when returning to the client.

## Data base
To store the platform data we're relying in PostgreSQL, which is an open source object-relational database, well known for its strong reliability, feature robustness and performance.
To configure the database a single master script was create, and can be found on the WIKI of the project repository <link>
This scrip includes not only the creation of the model with all its tables and dependencies, but also all the triggers and store procedures that allow a robust consistency on the database on the insertion of new data. 

The single master script was created through the merge of several individual ones used on the development phase such as scripts to create, delete, drop and fill the database for testing. The other scrips can be found as store procedures on the project repository

For database access to be possible a data source been was created to configured database related configurations, allowing a database connection to be used by the application to communicate with a given DB.
On the application spring Repositories were used to interact with the database, specifically CurdRepositorty and PagingAndSortingRepository. The CrudRepositorty is a repository with some CRUD operations already implemented and the PagingAndSortingRepository extends the CrudRepositorty supporting sorting and paging for DB operations.
To enable the repositories to perform database operations each repository was associated with a given class which represented the DB tables with which the repository would interact. As such these classes needed some configuration so the repository wold be able to know the table name, the field names and other related entities were there. To this effect the package `pt.isel.server.domain` contains several classes which were annotated with annotations from `org.hibernate.annotations` and `javax.persistence` packages in order to identify DB table names, column names, which of the properties were primary keys, identity keys and relations to other domains line one to many or many to one.







